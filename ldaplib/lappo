#!/usr/bin/env python
#
# lappo - LDAP client with login and schema support
#
# Copyright (C) 2000 Federico Di Gregorio  <fog@mixadlive.com>
# Copyright (C) 2000 MIXAD LIVE S.r.l.  [http://www.mixadlive.com]
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by the
# Free Software Foundation; either version 2, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTIBILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#
# -*- Mode: pyhton -*-
#

import sys, re, string, getopt, _gtk
import ldap, ldap.connection, ldap.parse
from gtk import *
from gnome.ui import *
from ldap.widgets import *


#################################################### global variables #########

version = '0.3'
program = 'lappo'
copyright = ('Copyright (C) 2000 Federico Di Gregorio <fog@mixadlive.com>\n' +
             'Copyright (C) 2000 MIXAD LIVE [http://www.mixadlive.com]')


# all the configuration options are kept in a single globally accessible
# dictionary (make better use of GNOME option saving here)
O = {}
O['modified'] = 0
O['auth_user'] = ''
O['auth_password'] = ''
O['ldap_server'] = 'localhost'
O['ldap_timeout'] = 30
O['ldap_search_default'] = 'cn=*'
O['use_rdn'] = TRUE
O['use_caution'] = TRUE


# all the important widget are kept easily accessible in a global dictionary
W = {}

# the LDAP connection is cached into this variable it is closed and reopened
# only after an error or a change in the authorization options
L = None



################################## simple widget data push/pop methods ########

def push_widget_data(widget, data):
    widget.set_data('__stack', data)

def push_widget_data_2(widget, name, data):
    try:
        d =  widget.get_data('__stack')
    except:
        d = None
    if d == None:
        widget.set_data('__stack', {name:data})
    else:
        d[name] = data

def pop_widget_data(widget):
    d = widget.get_data('__stack')
    widget.set_data('__stack', None)
    return d

def get_widget_data(widget):
    return widget.get_data('__stack')


#################################################### UI callback hooks ########

#### save the changes back to the directory
def action_save(widget, event=None):
    for n in W['tree'].roots:
        try:
            W['tree'].node_commit_ldap_data(n)
        except ldap.LDAPError, err:
            dialog_ldap('Commit failed:', err)
    O['modified'] = 0
    

#### tree selection caching, just to speed things up
def tree_select_row(tree, node, column, entry):
    """If the node contains an attribute value, copy it to the test entry;
       then updates the tree_selected_* entries in W."""
    global W
    W['tree_selected_node'] = node
    W['tree_selected_column'] = column
    d = entry[0].node_get_ldap_data(node)
    entry[1].set_text(d[1])
    entry[1].select_region(0,-1)
    entry[1].grab_focus()

def tree_unselect_row(tree, node, column, entry):
    global W
    W['tree_selected_node'] = None
    W['tree_selected_column'] = -1
    entry[1].set_text('')


#### editing in the text entry
def entry_changed(entry, tree):
    """Copy the changed text back to the tree node."""
    global W, O
    node = W['tree_selected_node']
    if node:
        if tree.node_set_ldap_data(node, entry.get_text()) != 0:
            O['modified'] = 1
            

#### text in the search widget: if it is a CR start the search
def search_activate(entry, tree):
    """Add the results on an LDAP search to the tree (actually replace.)"""
    global O
    if O['modified'] == 1:
        v = dialog_info("You made some modifications that will be lost.\n" +
                        "Do you really want to perform the search?",
                        'warning')
        if v != 0: return
    try:
        tree.set_search_base(O['basedn'], entry.get_text())
    except ldap.LDAPError, err:
        dialog_ldap('Error searching the directory:', err)


#### text in the base widget: if it is a CR reset the base
def base_activate(entry, tree):
    """Reset browse base"""
    global O
    if O['modified'] == 1:
        v = dialog_info("You made some modifications that will be lost.\n" +
                        "Do you really want to reset the base dn?",
                        'warning')
        if v != 0: return
    # if the final char of the new base is a ',', consider it a relative rdn
    n = entry.get_text()
    if n != '' and n[-1] == ',':
        n = canonical_dn(n, O['basedn'])
    try:
        tree.set_browse_base(n)
        O['basedn'] = n
        W['search'].set_text('')
    except ldap.LDAPError, err:
        dialog_ldap('Error accessing the directory:', err)
    entry.set_text(O['basedn'])
    

#### click on the delete button
def delete_clicked(button, tree):
    """If the current node is a valid dn, deletes it."""
    global W, O
    node = W['tree_selected_node']
    if node:
        d = tree.node_get_ldap_data(node)
        if d[0] == 'dn':
            v = dialog_info('Do you really want to delete the selected entry ' +
                            'and all its childrens?', 'warning')
            if v != 0: return
        try:
            tree.node_remove_ldap_data(node, d[0], d[1])
        except LDAPError, err:
            dialog_ldap("Error removing data or entry:", err)
            

#### click on the add button
def add_clicked(button, widgets):
    """Add a new entry to the tree and to the directory."""
    global W, O
    node = W['tree_selected_node']
    if node:
        d = widgets[0].node_get_ldap_data(node)
        if d[0] == 'dn':
            rdn = widgets[1].get_text()
            try:
                tree.node_add_ldap_entry(node, rdn)
            except LDAPError, err:
                dialog_ldap("Error adding new entry:", err)
                
                                     
################################################ UI building functions ########

#### preferences dialog
def dialog_prefs(widget, event=None):
    pbox = GnomePropertyBox()

    # the callbacks for the property box
    def apply_callback(widget, data=None):
        global O, L
        if data == -1:
            d = get_widget_data(widget)
            O['auth_user'] = d['auth_user_entry'].get_text()
            O['auth_password'] = d['auth_password_entry'].get_text()
            L.rebind(O['auth_user'], O['auth_password'])
            
    def destroy_callback(widget, data=None):
        pop_widget_data(widget)
        
    pbox.connect('apply', apply_callback)
    pbox.connect('ok', apply_callback)
    pbox.connect('destroy', destroy_callback)
    
    # first page: authorization preferences
    table = GtkTable(2, 2, 0)
    table.set_col_spacings(4)
    table.set_row_spacings(4)
    table.set_border_width(4)
    table.show()
    
    l = GtkLabel('Binding Dn'); l.show()
    e = GtkEntry(); e.show(); e.set_text(O['auth_user'])
    table.attach(l, 0,1, 0,1, xoptions=FILL)
    table.attach(e, 1,2, 0,1, xoptions=FILL+EXPAND)
    push_widget_data_2(pbox, 'auth_user_entry', e)

    l = GtkLabel('Password'); l.show()
    e = GtkEntry(); e.show(); e.set_text(O['auth_password'])
    table.attach(l, 0,1, 1,2, xoptions=FILL)
    table.attach(e, 1,2, 1,2, xoptions=FILL+EXPAND)
    push_widget_data_2(pbox, 'auth_password_entry', e)

    l = GtkLabel('Authentication'); l.show()
    pbox.append_page(table, l)
    pbox.show()
    
        
#### quit dialog
def dialog_quit(widget, event=None):
    if O['modified'] == TRUE:
	box = GnomeMessageBox('You made some modifications that will be ' +
                              'lost.\nDo you reallly want to quit?',
			      'question', STOCK_BUTTON_YES, STOCK_BUTTON_NO)
	box.set_modal(TRUE)
        button = box.run_and_close()
        if button == 0: mainquit()

    else:
	mainquit()
	
    return TRUE


#### about dialog
def dialog_about(widget, event=None):
    box = GnomeAbout('lappo',
		     version,
		     copyright,
		     ['Federico Di Gregorio <fog@mixadlive.com>'],
		     'LDAP client (hopefully will have schema support...)')
    box.show()
    return TRUE


#### generic message/ok only dialog
def dialog_info(msg, type='information', buttons=STOCK_BUTTON_OK):
    box = GnomeMessageBox(msg, type, buttons)
    box.set_modal(TRUE)
    v = box.run_and_close()
    return v

#### dialog yes/no
def

#### ldap error dialog
def dialog_ldap(msg, err):
    return dialog_info(msg + '\nServer returned: %s' % err, 'error')

#### select schema and try to open it    
def menu_open_schema(widget, event=None):
    pass
#    sel = GtkFileSelection('Select Schema')
#    sel.ok_button.connect('clicked',
#			  lambda widget, fs=sel:
#			  schema_load(fs.get_filename()))
#    sel.ok_button.connect('clicked', sel.destroy)
#    sel.cancel_button.connect('clicked', sel.destroy)
#    sel.show()
    

#### main application menu
def menu_build():
    file_menu = [
	UIINFO_ITEM_STOCK('New',
			  None, None, STOCK_MENU_NEW),
	UIINFO_ITEM_STOCK('Search...',
			  None, None, STOCK_MENU_SEARCH),
	UIINFO_ITEM_STOCK('Save changes',
			  None, action_save, STOCK_MENU_SAVE),
	UIINFO_SEPARATOR,
	UIINFO_ITEM_STOCK('Print...', None, None, STOCK_MENU_PRINT),
	UIINFO_ITEM_STOCK('Setup Page...', None, None, STOCK_MENU_BLANK),
	UIINFO_SEPARATOR,
	UIINFO_ITEM_STOCK('Quit', None, dialog_quit, STOCK_MENU_QUIT)]
   
    edit_menu = [
	UIINFO_ITEM_STOCK('Cut', None, None, STOCK_MENU_CUT),
	UIINFO_ITEM_STOCK('Copy', None, None, STOCK_MENU_COPY),
	UIINFO_ITEM_STOCK('Paste', None, None, STOCK_MENU_PASTE),
	UIINFO_ITEM_STOCK('Delete', None, None, STOCK_MENU_BLANK),
	UIINFO_SEPARATOR,
	UIINFO_ITEM_STOCK('Preferences...',
                          None, dialog_prefs, STOCK_MENU_PREF)]

    help_menu = [
	UIINFO_ITEM_STOCK('About...', None, dialog_about, STOCK_MENU_ABOUT)]
    
    menu_info = [
	UIINFO_SUBTREE('File', file_menu),
	UIINFO_SUBTREE('Edit', edit_menu),
	UIINFO_SUBTREE('Help', help_menu)]
    
    return menu_info


#### build main application area
def app_area_build(connection):
    "Builds the widgets used in the application main window area."

    global W, O

    # search/browse options
    table = GtkTable(3, 2, 0)
    table.set_col_spacings(4)
    table.set_row_spacings(4)
    table.set_border_width(4)
    table.show()
    
    frame = GtkFrame('Search/browse options')
    frame.show()
    frame.add(table)
    
    if O['basedn'] == None: basedn = '<directory base not set>'
    else: basedn = O['basedn']
    frame2 = GtkFrame('LDAP directory at '+basedn)
    frame2.show()
    #frame2.add(vbox2)
    # save a handle to frame2 to be able to change its label
    W['frame'] = frame2
    
    l = GtkLabel('Filter'); l.show()
    e = GtkEntry(); e.show();
    table.attach(l, 0,1, 2,3, xoptions=FILL)
    table.attach(e, 1,2, 2,3, xoptions=FILL+EXPAND)
    W['filter'] = e

    l = GtkLabel('Search'); l.show()
    e = GtkEntry(); e.show();
    table.attach(l, 0,1, 1,2, xoptions=FILL)
    table.attach(e, 1,2, 1,2, xoptions=FILL+EXPAND)
    W['search'] = e

    l = GtkLabel('Base'); l.show()
    e = GtkEntry(); e.show();
    e.set_text(O['basedn'])
    table.attach(l, 0,1, 0,1, xoptions=FILL)
    table.attach(e, 1,2, 0,1, xoptions=FILL+EXPAND)
    W['base'] = e

    # the main directory tree (with a scrolled window)
    tree = GtkLDAPDirectoryTree(connection) 
    tree.show()
    W['tree'] = tree
    scr = GtkScrolledWindow()
    scr.show()
    scr.set_policy(POLICY_AUTOMATIC, POLICY_ALWAYS)
    scr.add(tree)

    # modify stuff
    table2 = GtkTable(3, 3, 0)
    table2.set_col_spacings(4)
    table2.set_row_spacings(4)
    table2.set_border_width(4)
    table2.show()
    frame3 = GtkFrame('Builder')
    frame3.show()
    frame3.add(table2)

    l = GtkLabel('objectClass:'); l.show()
    ocs = GtkLDAPClassEntry(O['ocd']) ; ocs.show()
    b = GtkButton('Add') ; b.show()
    table2.attach(l, 0,1, 0,1, xoptions=FILL)
    table2.attach(ocs, 1,2, 0,1, xoptions=FILL+EXPAND)
    table2.attach(b, 2,3, 0,1, xoptions=FILL)
    W['ocs'] = ocs
    W['ocs_add'] = b
    
    # attribute values and add/delete stuff
    entry = GtkEntry()
    entry.show()
    W['entry'] = entry
    add = GtkButton('Add')
    add.show()
    W['add']= add
    delete = GtkButton('Delete') 
    delete.show()
    W['delete'] = delete
    
    buttonbox = GtkHBox(0, 0)
    buttonbox.pack_start(entry, TRUE, TRUE)
    buttonbox.pack_start(add, FALSE, TRUE)
    buttonbox.pack_start(delete, FALSE, TRUE)
    buttonbox.show()
    
    vbox2 = GtkVBox(0, 0)
    vbox2.set_border_width(4)
    vbox2.show()
    
    vbox2.pack_start(scr, TRUE, TRUE)
    vbox2.pack_start(buttonbox, FALSE, TRUE, 2)
    #vbox2.set_usize(300, -1)

    vbox = GtkVBox(0, 0)
    vbox.set_border_width(4)
    vbox.set_spacing(4)
    vbox.show()

    vbox.pack_start(frame, FALSE, TRUE)
    vbox.pack_start(frame3, FALSE, TRUE)

    pane = GtkHPaned()
    pane.pack1(vbox2, 1, 1)
    pane.pack2(vbox, 1, 0)
    pane.show()
    
    # connect signals
    tree.connect('tree-unselect-row', tree_unselect_row, (tree, entry))
    tree.connect('tree-select-row', tree_select_row, (tree, entry))
    entry.connect('changed', entry_changed, tree)
    delete.connect('clicked', delete_clicked, tree)
    add.connect('clicked', add_clicked, (tree, entry))
    W['search'].connect('activate', search_activate, tree)
    W['base'].connect('activate', base_activate, tree)
    
    W['main_box'] = pane
    return pane


################################################ main application loop ########

# some parameters from the commandline
if len(sys.argv) > 1:
    O['ldap_server'] = string.replace(sys.argv[1], ' ', '')

if len(sys.argv) > 2:
    O['basedn'] = string.replace(sys.argv[2], ' ', '')
else:
    O['basedn'] = None

if len(sys.argv) > 3:
    O['auth_user'] = sys.argv[3]
    O['auth_password'] = sys.argv[4]

if  len(sys.argv) > 5:
    O['ocd'] = ldap.parse.load_objectclasses_d(sys.argv[4])
else:
    O['ocd'] = ldap.parse.load_objectclasses_d('/etc/openldap/slapd.oc.conf') 


# open the ldap connection
L = ldap.connection.LDAPConnection(host=O['ldap_server'],
                                   binding_dn=O['auth_user'],
                                   auth_token=O['auth_password'])
L.base = O['basedn']

# build the GUI
app = GnomeApp('lappo', 'lappo')
app.set_wmclass('lappo', 'Lappo')
app.connect('delete_event', dialog_quit)
app.connect('destroy', mainquit)
app.set_default_size(500,300) 
app.create_menus(menu_build())
app.set_contents(app_area_build(L))
app.show()

try:
    mainloop()
except LDAPError, err:
    dialog_ldap("Generic LDAP error:", err)























